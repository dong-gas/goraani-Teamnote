\documentclass[landscape, 8pt, a4paper, oneside, twocolumn]{extarticle}

\usepackage[compact]{titlesec}
\titlespacing*{\section}
{0pt}{0px plus 1px minus 0px}{-2px plus 0px minus 0px}
\titlespacing*{\subsection}
{0pt}{0px plus 1px minus 0px}{0px plus 3px minus 3px}

\setlength{\columnseprule}{0.4pt}
\pagenumbering{arabic}

\usepackage{kotex}

\usepackage[left=0.8cm, right=0.8cm, top=2cm, bottom=0.3cm, a4paper]{geometry}
\usepackage{amsmath}
\usepackage{ulem}
\usepackage{amssymb}
\usepackage{minted}
\usepackage{color, hyperref}
\usepackage{indentfirst}
\usepackage{enumitem}

\usepackage{fancyhdr}
\usepackage{lastpage}
\pagestyle{fancy}
\lhead{Sogang - Goraani Never Stop}
\rhead{Page \thepage  \ of \pageref{LastPage} }
\fancyfoot{}

\headsep 0.2cm

\setminted{breaklines=true, tabsize=2, breaksymbolleft=}
\usemintedstyle{perldoc}

\title{Team Note of GoNeS}
\author{djs100201, dong\_gas, tkfkddl59323}
\date{Compiled on \today}

\newcommand{\revised}{Should be \textcolor{red}{\textbf{revised}}.}
\newcommand{\tested}{Should be \textcolor{red}{\textbf{tested}}.}
\newcommand{\added}{Should be \textcolor{red}{\textbf{added}}.}
\newcommand{\WIP}{\textcolor{red}{\textbf{WIP}}}

\begin{document}
{
	\Large
	\maketitle
    \tableofcontents
}
\thispagestyle{fancy}
\pagebreak
\section{Data Structure}
\subsection{Segment Tree}
\subsubsection {Segment Tree}
\begin{minted}{cpp}
// dong_gas
#include <bits/stdc++.h>
#define ll long long int
using namespace std;

/*
Segment Tree
*/

template<typename T> struct seg {
	ll n; //size
	T id; //identity
	vector<T> t;
	T(*merge)(T, T);
	seg(ll N, T ID, T(*_merge)(T, T)): n(N), id(ID), merge(_merge) { t.resize(N<<1, id); }					
	void update(ll p, T val) {
		for (t[p+=n] = val; p > 1; p >>= 1) {//if you want change value, t[p+=n] = newval
			if(p&1) t[p>>1] = merge(t[p^1], t[p]);
			else t[p>>1] = merge(t[p], t[p^1]);
		}
	}
	T query(ll l, ll r) {//query on interval [l, r)
		T lret=id, rret=id;
		for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
			if(l&1) lret = merge(lret, t[l++]);
			if(r&1) rret = merge(t[--r], rret);
		}
		return merge(lret, rret);
	}
};
\end{minted}
\newpage
\begin{minted}{cpp}
// tkfkddl59323 
#include <bits/stdc++.h>
#define ll long long int
using namespace std;
template<typename T>
struct Segtree {
	int S;
	vector<T> seg;
	T(*oper)(T, T);
	T e;
 
	Segtree(const vector<T>& arr, T _e = 0, T(*_oper)(T, T) = [](T a, T b) {return a + b; }) {
		int _n = arr.size();
		S = bit_ceil((unsigned int)_n);
		seg = vector<T>(2 * S, _e);
		oper = _oper;
		e = _e;

		for (int i = 0; i < _n; i++)
			seg[S + i] = arr[i];

		for (int SS = S / 2; SS > 0; SS /= 2)
			for (int i = SS; i < 2 * SS; i++)
				seg[i] = oper(seg[2 * i], seg[2 * i + 1]);
	}

	void update(int idx, T val) {
		idx += S;
		seg[idx] = val;
		for (idx >>= 1; idx > 0; idx >>= 1)
			seg[idx] = oper(seg[idx * 2], seg[idx * 2 + 1]);
	}

	T query(int l, int r) {
		T lret = e, rret = e;
		for (l += S, r += S; l <= r; l >>= 1, r >>= 1) {
			if (l & 1) lret = oper(lret, seg[l++]);
			if (r & 1 ^ 1) rret = oper(seg[r--], rret);
		}
		return oper(lret, rret);
	}

	// 이 아래는 bsquery가 필요할 때만 베껴쓸 것
	int BSquery(int val){
		int idx = 1;
		while(idx < S){
			idx *= 2;
			if(seg[idx] < val) val -= seg[idx++];
		}
		return idx-S;
	}
};
\end{minted}
\newpage
\subsubsection {Lazy Propagation}
\begin{minted}{cpp}
class lazy_seg{
	public:
	vector<ll> tree, lazy, A;
	lazy_seg(int n)
	{
		// 0~n까지 쓰겠다.
		tree.resize(n * 4);
		lazy.resize(n * 4);
		A.resize(n * 4);
	}
	ll init(ll N, ll s, ll e)
	{
		if (s == e)
			return tree[N] = A[s];
		ll mid = (s + e) / 2;
		return tree[N] = init(N * 2, s, mid) + init(N * 2 + 1, mid + 1, e);
	}
	void update_lazy(ll N, ll s, ll e)
	{
		if (!lazy[N])
			return;
		tree[N] += (e - s + 1) * lazy[N];
		if (s != e)
		{
			lazy[N * 2] += lazy[N];
			lazy[N * 2 + 1] += lazy[N];
		}
		lazy[N] = 0;
	}
	void update(ll N, ll s, ll e, ll l, ll r, ll val)
	{
		update_lazy(N, s, e);
		if (l > e || r < s)
			return;
		if (l <= s && e <= r)
		{
			lazy[N] = val;
			update_lazy(N, s, e);
			return;
		}
		ll mid = (s + e) / 2;
		update(N * 2, s, mid, l, r, val);
		update(N * 2 + 1, mid + 1, e, l, r, val);
		tree[N] = tree[N * 2] + tree[N * 2 + 1];
	}
	ll f(ll N, ll s, ll e, ll l, ll r)
	{
		update_lazy(N, s, e);
		if (l > e || r < s)
			return 0;
		if (l <= s && e <= r)
			return tree[N];
		ll mid = (s + e) / 2;
		return f(N * 2, s, mid, l, r) + f(N * 2 + 1, mid + 1, e, l, r);}};
\end{minted}
\newpage
\subsubsection {dynamic segment tree}
\begin{minted}{cpp}
struct Node{
    int l, r; //index of leftson, rightson
    ll v; //sum of interval
    Node(){ l = r = -1; v = 0; }
};
Node nd[4040404]; //enough size
//root: nd[0]
int pv = 1; //pv node already used..
void update(int node, int s, int e, int x, int v){
    if(s == e){
        nd[node].v = v; return;
    }
    int m = s + e >> 1;
    if(x <= m){
        if(nd[node].l == -1) nd[node].l = pv++;
        update(nd[node].l, s, m, x, v);
    }else{
        if(nd[node].r == -1) nd[node].r = pv++;
        update(nd[node].r, m+1, e, x, v);
    }
    ll t1 = nd[node].l != -1 ? nd[nd[node].l].v : 0;
    ll t2 = nd[node].r != -1 ? nd[nd[node].r].v : 0;
    nd[node].v = t1 + t2;
}
ll query(int node, int s, int e, int l, int r){
    if(node == -1) return 0;
    if(r < s || e < l) return 0;
    if(l <= s && e <= r) return nd[node].v;
    int m = s + e >> 1;
    return query(nd[node].l, s, m, l, r) + query(nd[node].r, m+1, e, l, r);
}
\end{minted}
\newpage
\subsubsection {persistent segment tree}
\begin{minted}{cpp}
struct PST {
    int l, r, v;
    PST() : l(0), r(0), v(0) {}
};
PST tree[300030]; //enough size!
int tn; //index of node
void update(int prv, int now, int s, int e, int idx, int v) {
    if(s==e) {
        tree[now].v=tree[prv].v+v;
        return;
    }
    int mid=s+e>>1;
    if(idx<=mid) {//update left
        if(tree[now].l==0 || tree[now].l==tree[prv].l) tree[now].l=tn++;
		//no leftson or same
        
        if(tree[now].r==0) tree[now].r=tree[prv].r;
		//if rightson is empty, use original node
        
        update(tree[prv].l,tree[now].l,s,mid,idx,v);
    }
    else {
        if(tree[now].r==0 || tree[now].r==tree[prv].r) tree[now].r=tn++;
        if(tree[now].l==0) tree[now].l=tree[prv].l;
        update(tree[prv].r,tree[now].r,mid+1,e,idx,v);
    }
    tree[now].v=tree[tree[now].l].v+tree[tree[now].r].v;
}

int query(int node, int s, int e, int l, int r) {
    if(l<=s && e<=r) return tree[node].v;
    if(s>r || e<l) return 0;
    int mid=s+e>>1;
    return query(tree[node].l,s,mid,l,r) + query(tree[node].r,mid+1,e,l,r);
}
\end{minted}
\newpage
\subsubsection {Li-Chao Tree}
\begin{minted}{cpp}
const ll inf = 2e18;
struct Line{
	ll a, b;
	ll get(ll x){ return a * x + b; }
};
struct Node{
	int l, r; //child
	ll s, e; //range
	Line line;
};
struct Li_Chao{
	vector<Node> tree;
	void init(ll s, ll e){ tree.push_back({ -1, -1, s, e, { 0, -inf } }); }
	void update(int node, Line v){
		ll s = tree[node].s, e = tree[node].e;
		ll m = s + e >> 1;
		Line low = tree[node].line, high = v;
		if (low.get(s) > high.get(s)) swap(low, high);
		if (low.get(e) <= high.get(e)){
			tree[node].line = high; return;
		}
		if (low.get(m) < high.get(m)){
			tree[node].line = high;
			if (tree[node].r == -1){
				tree[node].r = tree.size();
				tree.push_back({ -1, -1, m + 1, e, { 0, -inf } });
			}
			update(tree[node].r, low);
		}
		else{
			tree[node].line = low;
			if (tree[node].l == -1){
				tree[node].l = tree.size();
				tree.push_back({ -1, -1, s, m, { 0, -inf } });
			}
			update(tree[node].l, high);
		}
	}
	ll query(int node, ll x){
		if (node == -1) return -inf;
		ll s = tree[node].s, e = tree[node].e;
		ll m = s + e >> 1;
		if (x <= m) return max(tree[node].line.get(x), query(tree[node].l, x));
		else return max(tree[node].line.get(x), query(tree[node].r, x));
	}
} seg;
\end{minted}
\newpage
\subsection {pbds}
\begin{minted}{cpp}
#include <bits/extc++.h>
/*
if error with <bits/extc++.h>...
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
*/
using namespace __gnu_pbds;
template<class T> using PBDS = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template<class T> using multiPBDS = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;
PBDS<ll> s;
//s.order_of_key(x): number of less than x
//s.find_by_order(y): return yth element iterator (0-based).
//s={1, 2, 4, 6, 11} -> *s.find_by_order(2) -> 4
//multiPBDS
(1) use m_erase instead of erase
void m_erase(multiPBDS &OS, int val){
    int index = OS.order_of_key(val);
    multiPBDS::iterator it = OS.find_by_order(index);
    if(*it == val) OS.erase(it);
}
(2) find(x)
count! number of less than x with order_of_key := p
check! find_by_order(p) == x
\end{minted}
\newpage
\subsection {Line Container}
\begin{minted}{cpp}
//max query.. if you want min query, use it with m -> -m, k -> -k, query(q) -> -query(q).
struct Line {
	mutable ll k, m, p;
	bool operator<(const Line& o) const { return k < o.k; }
	bool operator<(ll x) const { return p < x; }
};
struct LineContainer : multiset<Line, less<>> {
	// (for doubles, use inf = 1/.0, div(a,b) = a/b)
	// (for doubles, const double inf = 1/.0;)
	// (for doubles, ll -> double)
	static const ll inf = LLONG_MAX;
	ll div(ll a, ll b) { // floored division
		return a / b - ((a ^ b) < 0 && a % b); }
	bool isect(iterator x, iterator y) {
		if (y == end()) return x->p = inf, 0;
		if (x->k == y->k) x->p = x->m > y->m ? inf : -inf;
		else x->p = div(y->m - x->m, x->k - y->k);
		return x->p >= y->p;
	}
	void add(ll k, ll m) {
		auto z = insert({k, m, 0}), y = z++, x = y;
		while (isect(y, z)) z = erase(z);
		if (x != begin() && isect(--x, y)) isect(x, y = erase(y));
		while ((y = x) != begin() && (--x)->p >= y->p)
			isect(x, erase(y));
	}
	ll query(ll x) {
		assert(!empty());
		auto l = *lower_bound(x);
		return l.k * x + l.m;
	}
};
\end{minted}
\newpage
\section{Geometry}
\subsection{Basic Template}
\begin{minted}{cpp}
struct pt{    
    ll x, y;
    pt() {x=0;y=0;}
    pt(ll p, ll q) {x=p, y=q;}
    pt operator + (pt t){return {x + t.x, y + t.y};}
    pt operator - (pt t){return {x - t.x, y - t.y};}
    ll operator * (pt t){return x * t.x + y * t.y;}
    ll operator / (pt t){return x * t.y - y * t.x;}
    bool operator == (const pt t)const{return x == t.x && y == t.y;}
    bool operator <(const pt t)const{return x == t.x ? y < t.y : x < t.x;}
    bool operator >(const pt t)const{return x == t.x ? y > t.y : x > t.x;}
    ll szz(){return x * x + y * y;}    
    pt mul(ll m){return {x * m, y * m};}
};

struct pt{ // long double
    ld x, y;
    pt() {x=(ld)0;y=(ld)0;}
    pt(ld p, ld q) {x=p, y=q;}
    pt operator + (pt t){return {x + t.x, y + t.y};}
    pt operator - (pt t){return {x - t.x, y - t.y};}
    ld operator * (pt t){return x * t.x + y * t.y;}
    ld operator / (pt t){return x * t.y - y * t.x;}
    //watch out! <, ==, >
    bool operator == (const pt t)const{return x == t.x && y == t.y;}
    bool operator <(const pt t)const{return x == t.x ? y < t.y : x < t.x;}
    bool operator >(const pt t)const{return x == t.x ? y > t.y : x > t.x;}
    ld szz(){return x * x + y * y;}    
    pt mul(ld m){return {x * m, y * m};}
};

ll ccw(pt a, pt b, pt c) {
    b = b - a, c = c - a;
    return b.x * c.y - c.x * b.y;
}

//외심 (실수) djs
pt get_circle_center(pt a,pt b,pt c){
	pt aa=b-a,bb=c-a;
	auto c1 = aa*aa * 0.5, c2 = bb*bb * 0.5;
    auto d = aa / bb;
    auto x = a.x + (c1 * bb.y - c2 * aa.y) / d;
    auto y = a.y + (c2 * aa.x - c1 * bb.x) / d;
    return pt(x, y);
}

// 다각형의 넓이 O(n)
double area(vector<pt>& v){
    double ret = 0;
    for(int i = 0, n = v.size(); i < n; i++)
        ret += v[i] / v[(i + 1) % n];
    return abs(ret) / 2.0;
}

\end{minted}
\newpage
\begin{minted}{cpp}

// 선분 교차 판정
bool intersect(pt p1, pt p2, pt p3, pt p4){
    int a = ccw(p1, p2, p3) * ccw(p1, p2, p4);
    int b = ccw(p3, p4, p1) * ccw(p3, p4, p2);
    if(!a && !b){
        if(p2 < p1) swap(p1, p2);
        if(p4 < p3) swap(p3, p4);
        return !(p2 < p3 || p4 < p1);
    }
    return a <= 0 && b <= 0;
}

// 두 선분의 교점 구하기
bool getpoint(pt p1, pt p2, pt p3, pt p4, pt& p){
    double d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
    double t = (p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x);
    double s = (p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x);
    if(!d){
        // t == 0 : 동일한 선
        
        // t != 0 : 평행
        if(p2 < p1) swap(p1, p2);
        if(p4 < p3) swap(p3, p4);
        
        // 한 점에서 만나는 경우
        if(p2 == p3) {
            p = p2; return 1;
        }    
        if(p4 == p1){
            p = p4; return 1;
        }
        return 0;
    }
    t /= d; s /= d;
    // t >= 0 && t <= 0 : 교점 존재
    p.x = p1.x + (p2.x - p1.x) * t;
    p.y = p1.y + (p2.y - p1.y) * t;
    return 1;
}

// 두 점 사이의 거리 (제곱)
ll dist(pt a, pt b){ return (b - a).sz(); }

// 직선(선분)과 점의 거리
double linedist(pt a, pt b, pt c){
    pt t = b - a;
    // 선분일 경우
    if(t * (c - a) <= 0) return sqrt(dist(a, c));
    if(t * (c - b) >= 0) return sqrt(dist(b, c));
    //   
    return abs(t / (c - a)) / sqrt(t.sz());
}


\end{minted}
\newpage
\begin{minted}{cpp}
// ConvexHull O(nlogn)
vector<pt> hull(vector<pt> v){
    int ix = min_element(all(v)) - v.begin();
    swap(v[0], v[ix]);
    vector<pt> st;
    
    sort(v.begin() + 1, v.end(), [&] (pt& a, pt& b){
       pt x = a - v[0], y = b - v[0];
       return x / y ? x / y > 0 : x.sz() < y.sz();
    });
    for(auto& p : v){
        while(st.size() > 1 && ccw(st[st.size() - 2], st.back(), p) <= 0) st.pop_back();
        st.emplace_back(p);
    }
    
    /*
    # 마지막 점들이 일직선 상에 있는 경우에 예외처리를 해야 하는 경우
    int i = v.size() - 1;
    while(i >= 1 && !ccw(v[0], v[i], v[i - 1])) i--;
    reverse(v.begin() + i, v.end());
    */
    return st;
}

// 삼각형 내부의 점 판별 O(1)
int inTriangle(vector<pt>& t, pt p){
    int sign[3];
    for(int i = 0; i < 3; i++)
        sign[i] = ccw(t[i], t[(i + 1) % 3], p);
    if(sign[0] == sign[1] && sign[1] == sign[2]) return -1;
    for(int i = 0; i < 3; i++) if(sign[i] * sign[(i + 1) % 3] == -1) return 1;
    return 0;
}

// 볼록 다각형 내부의 점 판별 O(n)
int inside(pt p, vector<pt>& v){
    if(v.size() < 3) return 0;
    for(int i = 0, n = v.size(); i < n; i++)
        if(ccw(v[i], v[(i + 1) % n], p) <= 0) return 0;
    return 1;
}

// 볼록 다각형 내부의 점 판별 O(logn)
int inside(pt p, vector<pt>& v){
    int n = v.size();
    if(n < 3 || ccw(v[0], v[1], p) < 0 || ccw(v[0], v[n - 1], p) > 0) return 0;
    
    int l = 2, r = n - 1, m;
    while(l < r){
        m = (l + r) / 2;
        if(ccw(v[0], v[m], p) < 0) r = m;
        else l = m + 1;
    }
    return ccw(v[l - 1], p, v[l]) < 0;
}
\end{minted}
\newpage
\begin{minted}{cpp}
//gumgood's code
ll ccw(pt a, pt b, pt c) {
    b = b - a, c = c - a;
    return b.x * c.y - c.x * b.y;
}

pt o(0,0);
sort(p.begin(), p.end(), [&](const pt &p,const pt &q){
    if((p<o)^(q<o)) return q < p;                   //사이 각 pi이내로만 한정. 영역을 o기준 좌/우로 나누고 우 영역 점이 먼저 오게 정렬
    if(ll t = ccw(o,p,q)) return t > 0;          
    return abs(p.x)<abs(q.x) || abs(p.y)<abs(q.y);  //같은 직선이라면 가까운 게 먼저
});
\end{minted}
\section{Graph}
\subsection {centroid}
\begin{minted}{cpp}
int sz[NMAX], use[NMAX], cent_papa[NMAX];
int get_size(int u, int p=0) {
    sz[u]=1;
    for(int v:adj[u]) {
        if(use[v] || p==v) continue;
        sz[u]+=get_size(v,u);
    }
    return sz[u];
}
int get_cent(int u, int p, int cnt) {
    for(int v:adj[u]) {
        if(use[v] || v==p) continue;
        if(sz[v]>cnt/2) return get_cent(v,u,cnt);
    }
    return u;
}
void dnc(int u, int p=0) {//p: before cent
    int cent=get_cent(u,p,get_size(u,p));
    cent_papa[cent]=p;
    use[cent]=1;
    for(int v:adj[cent]) if(!use[v]) dnc(v,cent);
}

/*
node update, node query -> you need to update all of your centroid ancestor
property: u-v route must pass u's centroid ancestor 
*/
void update(int u) {
    color[u]^=1;
    int now=u;
    do {
        int dist=get_dist(now,u);
        if(color[u]) s[now].insert(dist);
        else s[now].erase(s[now].find(dist));
        now=cent_papa[now];
    } while(now!=0);    
}
int query(int u) {
    int now=u, ret=1e9;
    do {        
        if(!s[now].empty()) ret=min(ret, get_dist(u,now) + *s[now].begin());
        now=cent_papa[now];        
    } while(now!=0);
    return (ret<1e9) ? ret : -1;
}
\end{minted}
\newpage

\subsection {Eulerian Circuit}
\begin{minted}{cpp}
vector<P>v[n_];
vector<ll>checked;
void dfs(ll x){
	while(1){
		while(v[x].size() && checked[v[x].back().second])v[x].pop_back();
		//쓴거 다 지우기
		if(v[x].empty())break;
		auto [a,b]=v[x].back();
		v[x].pop_back();
		checked[b]=true;
		dfs(a);
	}
	cout<<x<<' ';
}
void solve(){
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			cin>>a;
			if(i<j)continue;
			for(int k=0;k<a;k++){
				v[i].push_back({j,base});
				v[j].push_back({i,base});
				base++;
			}
		}
	checked.resize(base+1);
	for(int i=1;i<=n;i++){
		if(v[i].size()%2){
			cout<<"-1";
			return;
		}
	}
	dfs(1);
}

\end{minted}
\newpage

\subsection {Offline Dynamic Connectivity}
\begin{minted}{cpp}
 * 1. 정점 u, v를 잇는 간선 추가 * 2. 정점 u, v를 잇는 간선 제거 (이미 있다고 치자.) * 3. 그래프 상에서 두 정점이 연결되어 있는지 체크
일단, 체크하는 쿼리에 순서대로 1, 2, 3 ... 등의 시간을 붙여놓고, 각각의 간선에 대해서 "lifetime"을 계산해 놓는다. 3번째 체크 쿼리가 들어오고, 2 - 3을 잇는 간선이 추가되고, 6번째 체크 쿼리가 들어오고, 2 - 3을 잇는 간선이 제거된다면. 2 - 3 간선의 lifetime은 [4, 6]의 구간이라고 해석되는 것이다.이렇게 각각의 간선에 대해서 lifetime을 계산해두었을 때, 분할정복을 사용해서 문제를 해결할 수 있다. 체크 쿼리가 총 Q개라고 했을 때, Solve(1, Q, [lifetime이 계산된 간선 집합]) 을 호출하자. Solve(S, E, edge set) :  * 1. edge i의 lifetime을 [is, ie]라고 했을 때, is <= s && e <= ie인 간선들을 모두 union find에 추가. * 2. M = (S+E)/2 일때, 1의 조건을 만족치 않은 간선들 중...     * 2.1 Solve(S, M, [S, M]과 lifetime이 겹치는 edge set)     * 2.2 Solve(M+1, E, [M+1, E]와 lifetime이 겹치는 edge set) * 3. Union find 자료구조를, 1번 과정이 실행되기 전으로 rollback
 * path compression은 사용하지 않는다대신 rank compression을 사용한다. P * 재귀 호출 내에 stack을 잡아서, 어떠한 변화를 줬는지를 기록해놓는다. * rollback 시에는 스택에서 pop해가면서 변화들을 원상복구해놓으면 된다.시간 복잡도는 O(Qlg^2Q)이다. 구현 시 edge set을 그때그때 들고 다니지 않고 segment tree 스타일로 미리 전역에 박고 시작하면 깔끔하게 코딩할 수 있다. 
struct disj{
	int pa[MAXN];
	int rk[MAXN];
	int cnt;
	void init(int n){
		iota(pa, pa + n + 1, 0);
		cnt = n;
	}
	int find(int x){ return (pa[x] == x ? x : find(pa[x])); }
	bool uni(int s, int e, vector<pi> &v){
		s = find(s);
		e = find(e);
		if(s == e) return 0;
		if(rk[s] < rk[e]){
			pa[s] = e;
			v.push_back({s, 1});
		}
		else{
			pa[e] = s;
			v.push_back({e, 1});	
		}
		if(rk[s] == rk[e]){
			v.push_back({s, -1});
			rk[s]++;
		}
		cnt--;
		return 1;
	}
	int query(){ return cnt; }
	void rvt(vector<pi> &v, int &c){
		cnt = c;
		while(!v.empty()){
			auto x = v.back();
			v.pop_back();
			if(x.second == -1) rk[x.first]--;
			else pa[x.first] = x.first;
		}
	}
}disj;
struct query{ int s, e, x, y; };
int buf;
pi qr[MAXN];
void solve(int s, int e, vector<query> v){
	if(s == e){
		int k = disj.query();
		vector<pi> rvt;
		for(auto &i : v) disj.uni(i.x, i.y, rvt);
        int i = s;
		printf("%d\n", disj.find(qr[i].first) == disj.find(qr[i].second));
		disj.rvt(rvt, k);
		return;
	}
	int m = (s+e)/2;
	int k = disj.query();
	vector<query> l, r;
	vector<pi> rvt;
	for(auto &i : v){
		if(i.s <= s && e <= i.e) disj.uni(i.x, i.y, rvt);
		else{
			if(i.s <= m) l.push_back(i);
			if(m < i.e) r.push_back(i);
		}
	}
	solve(s, m, l);
	solve(m+1, e, r);
	disj.rvt(rvt, k);
}
int main(){
	int n, q, m = 0;map<pi, int> mp;vector<query> v;
	scanf("%d %d",&n,&q);
	disj.init(n);
	for(int i=1; i<=q; i++){
		int x, y;
		scanf("%d", &buf);
        buf += '0';
        scanf("%d %d",&x,&y);
        if(x > y) swap(x, y);
		if(buf == '1'){
			mp[pi(x, y)] = m;
		}
		else if(buf == '2'){
			if(mp[pi(x, y)] <= m - 1) v.push_back({mp[pi(x, y)], m-1, x, y});
			mp.erase(pi(x, y));
		}
		else{
			qr[m++] = pi(x, y);
		}
	}
	for(auto &i : mp) if(i.second<m) v.push_back({i.second, m-1, i.first.first, i.first.second});
	if(m > 0){
		solve(0, m-1, v);
	}
}

\end{minted}
\newpage
\subsection {Articulation Point}
\begin{minted}{cpp}
//단절점
vector<ll>v[n_],res;
ll checked[n_],dep[n_],low[n_];
void dfs(ll x,ll par){
    dep[x]=low[x]=base++;
    bool flag=0;
    int cnt=0;
    for(auto nxt:v[x]){
        if(nxt==par)continue;
        if(checked[nxt]){
            low[x]=min(low[x],dep[nxt]);
            continue;
        }
        checked[nxt]=true;
        dfs(nxt,x);
        if(par && dep[x]<=low[nxt])flag=1;
        low[x]=min(low[x],low[nxt]);
        cnt++;
    }
    if(par==0 && cnt>=2)flag=true;
    if(flag)res.push_back(x);
    
}
void solve(){
    cin>>n>>m;
    while(m--){
        cin>>a>>b;
        v[a].push_back(b);
        v[b].push_back(a);
    }
    for(int i=1;i<=n;i++){
        if(checked[i])continue; 
        checked[i]=true;
        dfs(i,0);
    }
    cout<<res.size()<<endl;
    sort(all(res));
    for(auto nxt:res)cout<<nxt<<' ';
    
    
}

\end{minted}
\newpage

\subsection {Bridge}
\begin{minted}{cpp}
//단절선
vector<pair<ll, ll>>ans;
ll dfs(ll x, ll par) {
	A[x] = ++d;
	ll ret = A[x];
	for (ll nxt : v[x]) {
		if (nxt == par)continue;
		if (!A[nxt]) {
			a = dfs(nxt, x);
			if (a > A[x])
				ans.push_back({ min(x,nxt),max(x,nxt) });
			ret = min(ret, a);
		}
		else ret = min(ret, A[nxt]);
	}
	return ret;
}
int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> V >> E;
	for (int i = 0; i < E; i++) {
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	dfs(1, 0);
	sort(ans.begin(), ans.end());
	cout << ans.size() << '\n';
	for (int i = 0; i < ans.size(); i++) {
		cout << ans[i].first << ' ' << ans[i].second << '\n';
	}

}

\end{minted}
\newpage
\subsection {HLD}
\begin{minted}{cpp}
/*
you need read input on g (not inp)
you need to call hld.init() after convert g -> inp 
hld.update(u, val);
hld.query(u, v);
you don't need concern in[u] or in[v], because template do that
*/
struct Heavy_Light_Decomposition {
    ll sz[NMAX], dep[NMAX], papa[NMAX], top[NMAX], in[NMAX], out[NMAX], pv;
    vector<ll> inp[NMAX], g[NMAX];
    //inp: input graph(bidrectional), g: convert inp to one-way graph
    void init() {
        dfs(1,0), dfs1(1), dfs2(1);
    }
    void dfs(int u, int p) {
        for(auto& v: inp[u]) if(v!=p) {
            dfs(v,u);
            g[u].emplace_back(v);
        }
    }
    void dfs1(int u) {
        sz[u]=1;
        for(auto &v: g[u]) {
            dep[v]=dep[u]+1, papa[v]=u;
            dfs1(v), sz[u]+=sz[v];
            if(sz[v]>sz[g[u][0]]) swap(v, g[u][0]);
        }
    }
    void dfs2(int u) {
        in[u]=++pv;
        for(auto v:g[u]) {
            top[v]=(v==g[u][0])?top[u]:v;
            dfs2(v);
        }
        out[u]=pv;
    }
    void update(int u, int val) {
        seg.update(in[u], val);                  
    }
    ll query(int u, int v) {
        ll ret=0;
        while(top[u] ^ top[v]) {
            if(dep[top[u]]<dep[top[v]]) swap(u,v);
            int st=top[u];
            ret+=seg.query(in[st], in[u]);     
            u=papa[st];
        }
        if(dep[u]>dep[v]) swap(u,v);
        ret+=seg.query(in[u], in[v]);            
        return ret;
    }
} hld;
\end{minted}
\newpage
\subsection {SCC + 2-sat}
\begin{minted}{cpp}
//in 2-sat 
//(a & b) -> (a or a) & (b or b)
//(a ^ b) -> (a or b) & (!a or !b)
ll n, m, id, SN = 1;
ll d[200020], sn[200020], ans[200020];
bool finished[200020];
vector<ll> adj[200020];
vector<vector<ll>> SCC;
stack<ll> s;
//reverse SCC -> topology sort
ll dfs(ll x) {
    d[x] = ++id;
    s.push(x);
    ll parent = d[x];
    for (ll i = 0; i < adj[x].size(); i++) {
        ll y = adj[x][i];
        if (d[y] == 0) parent = min(parent, dfs(y));
        else if (!finished[y]) parent = min(parent, d[y]);
    }
    if (parent == d[x]) {
        vector<ll> scc;
        while (1) {
            ll t = s.top();
            s.pop();
            scc.push_back(t);
            finished[t] = true;
            sn[t] = SN;
            if (t == x) break;
        }
        SCC.push_back(scc);
        SN++;
    }
    return parent;
}
ll rev(ll x) { //get not in 2-sat
	if (x <= n) return x + n;
	return x - n;
}
void solve() {
    cin >> n >> m;
    while (m--) {
        ll u, v; cin >> u >> v;
        adj[u].push_back(v);
    }
    for (ll i = 1; i <= 2 * n; i++) if (!d[i]) dfs(i);
    
    //2-sat start
    //(a or b) -> !a->b, !b->a
    for (ll i = 1; i <= n; i++) {
		if (sn[i] == sn[i + n]) {//same SCC
			cout << 0 << endl;
			return;
		}
	}
	cout << 1 << endl;
	reverse(SCC.begin(), SCC.end()); //topology sort
	for (auto vec : SCC) {
		for (auto now : vec) {//Starting from the front, fill in 0 first.
			if (ans[now]) continue;
			ans[now] = 0;
			ans[rev(now)] = 1;
		}
	}    
}
\end{minted}
\newpage
\subsection {O(1) LCA with O(NlogN) preprocessing}
\begin{minted}{cpp}
const int NMAX = 100201;
int n, q, ord;
int depth[NMAX], idx[NMAX], log_2[2*NMAX], euler[2*NMAX];
pint dp[22][2*NMAX];
vector<int> adj[NMAX];
void dfs(int now, int papa=0) {
    depth[now]=depth[papa]+1;
    idx[now]=++ord;
    euler[ord]=now;
    for(int nxt:adj[now]) if(nxt != papa) {
        dfs(nxt, now);
        euler[++ord]=now;
    }
}
void init() {
    int j=-1;
    for(int i=1;i<=ord;i++) {
        if(1<<(j+1)==i) j++;
        log_2[i]=j;
    }
    for(int i=1;i<=ord;i++) dp[0][i]={depth[euler[i]],euler[i]};
    for(int j=1;j<22;j++) for(int i=1;i+(1<<(j-1))<=ord;i++) dp[j][i]=min(dp[j-1][i], dp[j-1][i+(1<<(j-1))]);
}
int get_lca(int u, int v) {
    int l=idx[u], r=idx[v];
    if(l>r) swap(l,r);
    int len=log_2[r-l+1];
    return min(dp[len][l], dp[len][r-(1<<len)+1]).second;
}
void solve() {
    cin>>n;
    for(int i=0;i<n-1;i++) {
        int u, v; cin>>u>>v;
        adj[u].emplace_back(v), adj[v].emplace_back(u);
    }
    dfs(1), init();
    cin>>q;    
    while(q --> 0) {
        int u, v; cin>>u>>v;
        cout<<get_lca(u,v)<<'\n';
    }
}
\end{minted}
\newpage
\section{Math}
\subsection{convolution(and, or, xor)}
\begin{minted}{cpp}
    void fwht_and(vector<ll> &a, bool inv) {
    ll n = a.size();
    ll dir = inv ? -1 : 1;
    for(ll s = 2, h = 1; s <= n; s <<= 1, h <<= 1)
        for(ll l = 0; l < n; l += s)
            for(ll i = 0; i < h; i++)
                a[l + i] += dir * a[l + h + i];
}
void fwht_or(vector<ll> &a, bool inv) {
    ll n = a.size();
    ll dir = inv ? -1 : 1;
    for(ll s = 2, h = 1; s <= n; s <<= 1, h <<= 1)
        for(ll l = 0; l < n; l += s)
            for(ll i = 0; i < h; i++)
                a[l + h + i] += dir * a[l + i];
}
void fwht_xor(vector<ll> &a, bool inv) {
    ll n = a.size();
    for(ll s = 2, h = 1; s <= n; s <<= 1, h <<= 1) {
        for(ll l = 0; l < n; l += s) {
            for(ll i = 0; i < h; i++) {
                ll t = a[l + h + i];
                a[l + h + i] = a[l + i] - t;
                a[l + i] += t;
                if(inv) a[l + h + i] /= 2, a[l + i] /= 2;
            }
        }
    }
}
vector<ll> convolution(vector<ll> a, vector<ll> b) {
    fwht_xor(a, false); //and or xor
    fwht_xor(b, false); //and or xor
    for(ll i=0;i<(1ll<<n);i++) a[i]*=b[i];
    fwht_xor(a, true);  //and or xor
    return a;
}
\end{minted}
\newpage
\subsection{CRT}
\begin{minted}{cpp}
    //ax+by=1의 값을 x,y에 저장해준다. gcd(a,b)를 return 해준다.
ll ex_gcd(ll a, ll b, ll& x, ll& y) {
	if (!b) {
		x = 1, y = 0;
		return a;
	}
	ll ret = ex_gcd(b, a % b, x, y);
	ll temp = y;
	y = x - (a / b) * y;
	x = temp;
	if (x <= 0) {
		x += b;
		y -= a;
	}
	return ret;
}
ll crt(vector<ll>&A, vector<ll>&B) {
	//b로 나눴을 때, 나머지가 a
	ll a1 = A[0], b1 = B[0];
	for (int i = 1; i < A.size(); i++) {
		ll x,  y, a2 = A[i], b2 = B[i], G = gcd(b1, b2);
		if ((abs(a2 - a1)) % G)return -1;
		ex_gcd(b1 / G, b2 / G ,x, y);
		x *=(a2 - a1) / G;
		x %= (b2 / G);
		x = (x + b2 / G) % (b2 / G);
		ll t = b1 * b2 / G;
		a1 = b1 * x + a1;
		a1 %= t;
		b1 = t;
	}
	return a1;
}
void solve() {
	n = 3;
	vector<ll>A(n), B(n);
	for (int i = 0; i < n; i++)cin >> B[i];
	for (int i = 0; i < n; i++)cin >> A[i];
	cout << crt(A, B) << '\n';
}
\end{minted}
\newpage
\subsection{FFT}
\begin{minted}{cpp}
// if TLE, long double -> double (less precise...)
#define double long double 
typedef complex<double> base;
void fft(vector <base>& a, bool invert)
{
	int n = sz(a);
	vector<base>roots(n / 2);
	for (int i = 1, j = 0; i < n; i++) {
		int bit = n >> 1;
		for (; j >= bit; bit >>= 1) j -= bit;
		j += bit;
		if (i < j) swap(a[i], a[j]);
	}
	for (int i = 2; i <= n; i <<= 1) {
		vector<base> w(i / 2);
		for (int j = 0; j < i / 2; ++j) {
			double th = 2 * acos(-1.L)*j / i * (invert ? -1 : 1);
			w[j] = base(cos(th), sin(th));
		}
		for (int j = 0; j < n; j += i) {
			for (int k = 0; k < i / 2; ++k) {
				base u = a[j + k], v = a[j + k + i / 2] * w[k];
				a[j + k] = u + v;
				a[j + k + i / 2] = u - v;
			}
		}
	}
	if (invert)	for (int i = 0; i < n; i++)a[i] /= n;
}
void multiply(const vector<ll>& a, const vector<ll >& b, vector<ll>& res)
{
	vector <base> fa(all(a)), fb(all(b));
	ll n = 1;
	while (n < max(sz(a), sz(b))) n <<= 1;
	n <<= 1;
	fa.resize(n); fb.resize(n);
	fft(fa, false); fft(fb, false);
	for (int i = 0; i < n; i++) fa[i] *= fb[i];
	fft(fa, true);
	res.resize(n);
	for (int i = 0; i < n; i++) res[i] = ll(fa[i].real() + (fa[i].real() > 0 ? 0.5 : -0.5));
}
\end{minted}
\newpage
\subsection{NTT}
\begin{minted}{cpp}
    ll pw(ll a, ll b, ll mod){
    ll ret = 1;
    while(b){
        if(b & 1) ret = ret * a % mod;
        b >>= 1; a = a * a % mod;
    }
    return ret;
}
 
template<ll mod, ll w>
class NTT{
public:
    void ntt(vector<ll> &f, bool inv = 0){
        int n = f.size(), j = 0;
        vector<ll> root(n >> 1);
        for(int i=1; i<n; i++){
            int bit = (n >> 1);
            while(j >= bit){
                j -= bit; bit >>= 1;
            }
            j += bit;
            if(i < j) swap(f[i], f[j]);
        }
        ll ang = pw(w, (mod - 1) / n, mod); if(inv) ang = pw(ang, mod - 2, mod);
        root[0] = 1; for(int i=1; i<(n >> 1); i++) root[i] = root[i-1] * ang % mod;
        for(int i=2; i<=n; i<<=1){
            int step = n / i;
            for(int j=0; j<n; j+=i){
                for(int k=0; k<(i >> 1); k++){
                    ll u = f[j | k], v = f[j | k | i >> 1] * root[step * k] % mod;
                    f[j | k] = (u + v) % mod;
                    f[j | k | i >> 1] = (u - v) % mod;
                    if(f[j | k | i >> 1] < 0) f[j | k | i >> 1] += mod;
                }
            }
        }
        ll t = pw(n, mod - 2, mod);
        if(inv) for(int i=0; i<n; i++) f[i] = f[i] * t % mod;
    }
    vector<ll> multiply(vector<ll> &_a, vector<ll> &_b){
        vector<ll> a(all(_a)), b(all(_b));
        int n = 2;
        while(n < a.size() + b.size()) n <<= 1;
        a.resize(n); b.resize(n);
        ntt(a); ntt(b);
        for(int i=0; i<n; i++) a[i] = a[i] * b[i] % mod;
        ntt(a, 1);
        return a;
    }
};






NTT<mod, w> ntt; //mod값, 원시근 넣고 사용

/*
mod / w
998'244'353 3
985'661'441 3
1'012'924'417 5
2'281'701'377 3
2'483'027'969 3
2'113'929'217 5
104'857'601 3
1'092'616'193 3
2013265921 31
*/
\end{minted}
\newpage
\subsection{Extended Euclidean \& MOD Inverse}
\begin{minted}{cpp}
#define MOD 998244353
#define ll long long
#define tll array<ll, 3>
// ax + by = g
// eeu(a, b) return : [g, y, x] (y, x 순서 반대인거 주의)

// (x, y값 음수 나올 수 있음 주의)
// x 양수화 : (x + b) % b, y 양수화 : (y + a) % a

tll eeu(ll a, ll b) { 
	if (a == 0) return { b, 1, 0 };
	else {
		auto [g, x, y] = eeu(b % a, a);
		return { g, y, x - b / a * y };
	}
}



// MOD inverse 
auto [_, __, a_inv] = eeu(a, MOD);
a_inv = (a_inv + MOD) % MOD;
\end{minted}
\newpage
\subsection{Miller Rabin}
\begin{minted}{cpp}
    //O(k(logN)^3)
//k: number of test
using ull = unsigned long long;
ull mul(ull x, ull y, ull mod){ return (ull)((__int128) x * y % mod); }
ull ipow(ull x, ull y, ull p){
  ull ret = 1, piv = x % p;
	while(y){
		if(y&1) ret = mul(ret, piv, p);
		piv = mul(piv, piv, p);
		y >>= 1;
	}
	return ret;
}
bool miller_rabin(ull x, ull a){
	if(x % a == 0) return 0;
	ull d = x - 1;
	while(1){
		ull tmp = ipow(a, d, x);
		if(d&1) return (tmp != 1 && tmp != x-1);
		else if(tmp == x-1) return 0;
		d >>= 1;
	}
}
bool isprime(ll x){ //long long range
	for(auto &i : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}){
		if(x == i) return 1;
		if(x > 40 && miller_rabin(x, i)) return 0;
	}
	if(x <= 40) return 0;
	return 1;
}
bool isprime(int x){ //int range
	for(auto &i : {2, 7, 61}){
    		if (x == i) return 1;
		if (miller_rabin(x, i)) return 0;
	}
	return 1;
}
\end{minted}
\newpage
\subsection{Pollard rho}
\begin{minted}{cpp}
// **밀러 라빈에 있는 몇몇 코드 가져와야 할 수도 있음** //
//integer factorization O(N^1/4)
ll gcd(ll a,ll b) {
    if(!b) return a;
    return gcd(b,a%b);
}
void rec(ll n, vector<ll>& v) {
	if (n == 1) return;
	if (n % 2 == 0) {
		v.push_back(2);
		rec(n / 2, v);
		return;
	}
	if (isprime(n)) {
		v.push_back(n);
		return;
	}
	ll a, b, c, g = n;
	auto f = [&](ll x) {
        	return (c + mul(x, x, n)) % n;
    	};
    	do {
        	if (g == n) {
            		a = b = rand() % (n - 2) + 2;
            		c = rand() % 20 + 1;
        	}
        	a = f(a);
        	b = f(f(b));
        	g = gcd(abs(a - b), n);
    	} while (g == 1);
	rec(g, v);
	rec(n / g, v);
}
vector<ll> factorize(ll n) {
	vector<ll> ret;
	rec(n, ret);
	sort(ret.begin(), ret.end());
	return ret;
}
\end{minted}
\newpage

\subsection{Gauss mod}
\begin{minted}{cpp}
//O(n^3)
vector<int> gauss_mod(vector<vector<int>> &a,int mod){
    vector<int> inv(mod); // modulo inverse
    inv[1] = 1;
    for(int i = 2; i < mod; ++i)
        inv[i] = mod - (mod/i) * inv[mod%i] % mod;


    int n = a.size();
    int m = a[0].size();
	//cout<<n<<' '<<m<<endl;

    vector<int> w(m, -1); // i번째 열에 있는 pivot이 몇 번째 행에 있는지 저장
    for(int c = 0, r = 0; c < m && r < n; ++c){
        int p = r; // pivot row
        for(int i = r; i < n; ++i)
            if(a[p][c] < a[i][c])
                p = i;
        if(a[p][c] == 0) continue; // free variable


        for(int j = 0; j < m; ++j)
            swap(a[p][j], a[r][j]);
        w[c] = r;


        int t = a[r][c];
        for(int j = 0; j < m; ++j)
            a[r][j] = a[r][j] * inv[t] % mod;


        for(int i = 0; i < n; ++i) if(i != r){
            int t = a[i][c];
            for(int j = c; j < m; ++j)
                a[i][j] = (a[i][j] - a[r][j] * t % mod + mod) % mod;
        }
        ++r;
    }


    // existence of solution
    for(int i = 0; i < n; ++i)
        if(count(a[i].begin(), --a[i].end(), 0) == m-1 && a[i][m-1])
            return vector<int>(); // no solution


    vector<int> ans(m);
    for(int i = 0; i < m; ++i)
        if(~w[i]) ans[i] = a[w[i]][m-1];
    return ans; // solution exist
}

void solve(){
	cin>>n;
	vector<vector<int>>G;
	for(int i=1;i<=n;i++){
		vector<int>T(n+1);
		for(int j=0;j<=n;j++)cin>>T[j];
		G.push_back(T);
	}
	vector<int>res=gauss_mod(G,101);
	for(int i=0;i<n;i++)cout<<res[i]<<' ';
	cout<<'\n';
}
\end{minted}
\newpage
\subsection{Matrix Multiplication}
\begin{minted}{cpp}

matrix operator *(const  matrix &a, const  matrix &b) {
	ll size = a.size(), size2 = b[0].size(), size3 = b.size();
	matrix res(size, vector<ll>(size2));
	for (int i = 0; i < size; i++)
		for (int j = 0; j < size2; j++) {
			for (int k = 0; k < size3; k++) {
				res[i][j] += a[i][k] * b[k][j];
				res[i][j] %= MOD;
			}
			res[i][j] %= MOD;
		}
	return res;
}
matrix power(matrix a, ll n) {//a행렬을 n제곱 하겠다!
	ll size = a.size();
	matrix res(size, vector<ll>(size));
	for (int i = 0; i < size; i++)res[i][i] = 1;//단위 행렬 생성
	while (n) {
		if (n % 2)res = res * a;
		n /= 2;
		a = a * a;

	}
	return res;
}


using poly = vector<ll>;
poly mul(const poly& a, const poly& b) {
	poly ret(a.size() + b.size() + 1);
	for (int i = 0; i < a.size(); i++)
		for (int j = 0; j < b.size(); j++)ret[i + j] = (ret[i + j] + a[i] * b[j]) % mod;
	return ret;
}
poly div(const poly& a, const poly& b) {
	poly ret = a;
	for (int i = ret.size() - 1; i >= b.size() - 1; i--)
		for (int j = 0; j < b.size(); j++) {
			ret[i + j - b.size() + 1] = ((ret[i + j - b.size() + 1] - ret[i] * b[j]) % mod + mod) % mod;
	}
	ret.resize(b.size() - 1);
	return ret;
}
//키타마사법 O(k^2n^3)
ll kitamasa(poly c, poly a, ll n) {
	//초기항 a[i]와 상수 c[i]
	poly result = { 1 };
	poly xn = { 0,1 };//xn= x^1, x^2, x^n
	poly f(c.size() + 1);
	f.back() = 1;
	for (int i = 0; i < c.size(); i++)f[i] = ((-c[i]) % mod + mod) % mod;
	while (n) {
		if (n % 2)result = div(mul(result, xn), f);
		n /= 2;
		xn = div(mul(xn, xn), f);
	}
	ll ret = 0;
	for (int i = 0; i < a.size(); i++) {
		ret += a[i] * result[i];
		ret %= mod;
		ret += mod;
		ret %= mod;
	}
	return ret;
}
\end{minted}
\newpage
\section{String}
\subsection{hashing}
\begin{minted}{cpp}
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
struct Hashing {
	const ll M=998244353;
	ll P;
    vector<ll> H, B;
    void Build(const string& S, ll cnt) { //cnt: number of character
		//if cnt+1 < enough gap < sqrt(M), use f(cnt+1, sqrt(M))
		static uniform_int_distribution<int> f(cnt+1, M - 1);
		P=f(rng);
        H.resize(S.size() + 1);
        B.resize(S.size() + 1);
        B[0] = 1;
        for (ll i = 1; i <= S.size(); i++) H[i] = (H[i - 1] * P + S[i - 1]) % M;
        for (ll i = 1; i <= S.size(); i++) B[i] = B[i-1] * P % M;
    }
    ll sub(ll s, ll e) { //call with 0-based
        s++; e++;
		ll ret = (H[e] - H[s - 1] * B[e - s + 1]) % M;
		return ret < 0 ? ret + M : ret;
    }
};

//double hashing
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
struct Hashing {
	const ll M0=998244353, M1=1'000'000'007;
	ll P0, P1;
    vector<vector<ll>> H, B;
    void Build(const string& S, ll cnt) { //cnt: number of character
		//if cnt+1 < enough gap < sqrt(M), use f(cnt+1, sqrt(M))
		static uniform_int_distribution<int> f(cnt+1, M0 - 1);
		static uniform_int_distribution<int> g(cnt+1, M1 - 1);
		P0=f(rng), P1=g(rng);
        H.resize(S.size() + 1,vector<ll>(2));
        B.resize(S.size() + 1,vector<ll>(2));
        B[0][0] = B[0][1]= 1;
        for (ll i = 1; i <= S.size(); i++) {
			H[i][0] = (H[i - 1][0] * P0 + S[i - 1]) % M0;
			H[i][1] = (H[i - 1][1] * P1 + S[i - 1]) % M1;
		}
        for (ll i = 1; i <= S.size(); i++) {
			B[i][0] = B[i-1][0] * P0 % M0;
			B[i][1] = B[i-1][1] * P1 % M1;
		}
    }
    pll sub(ll s, ll e) { //call with 0-based
        s++; e++;
		ll ret0 = (H[e][0] - H[s - 1][0] * B[e - s + 1][0]) % M0;
		ll ret1 = (H[e][1] - H[s - 1][1] * B[e - s + 1][1]) % M1;
		if(ret0 < 0) ret0 += M0;
		if(ret1 < 0) ret1 += M1;
        return {ret0, ret1};
    }
};
\end{minted}
\newpage
\subsection{KMP}
\begin{minted}{cpp}
string s, t;
ll fail[1000010];
vector<ll> ans;
void kmp() {
	getline(cin, s);
	getline(cin, t);
	for (ll i = 1, j = 0; i < t.size(); i++) {
		while (j > 0 && t[i] != t[j]) j = fail[j - 1];
		if (t[i] == t[j]) fail[i] = ++j;
	}
	for (ll i = 0, j = 0; i < s.size(); i++) {
		while (j > 0 && s[i] != t[j]) j = fail[j - 1];
		if (s[i] == t[j]) {
			if (j == t.size() - 1) {
				ans.push_back(i - t.size() + 2);
				j = fail[j];
			}
			else j++;
		}
	}
	cout << ans.size() << endl;
	for (ll i = 0; i < ans.size(); i++) cout << ans[i] << endl;
}
\end{minted}
\vspace{5mm}
\subsection{manacher}
\begin{minted}{cpp}
ll n, ans;
ll a[N]; //a[i]: Maximum length of palindrome centered on i
string s, t;
void solve() {
    cin >> s;
    n = s.size();
    for (ll i = 0; i < n; i++) t += '#', t += s[i];
    t += '#';
    n = t.size();
    ll r = 0, p = 0;
    for (ll i = 0; i < n; i++) {
        if (i <= r) a[i] = min(a[2 * p - i], r - i);
        else a[i] = 0;
        while (i - a[i] - 1 >= 0 && i + a[i] + 1 < n && t[i - a[i] - 1] == t[i + a[i] + 1]) a[i]++;
        if (r < i + a[i]) r = i + a[i], p = i;
    }
}
\end{minted}
\newpage
\subsection{suffix array \& lcp}
\begin{minted}{cpp}
vector<ll> SA(string& s) { //O(nlogn)
    ll n = s.size(), m = max(256LL, n) + 1;
    vector<ll> sa(n), r(n + n), nr(n + n), idx(n), cnt(m);
    for (ll i = 0; i < n; i++) sa[i] = i, r[i] = s[i];
    for (ll d = 1; d < n; d <<= 1) {
        auto cmp = [&](ll i, ll j) {
            return r[i] < r[j] || (r[i] == r[j] && r[i + d] < r[j + d]);
        };
        for (ll i = 0; i < m; i++) cnt[i] = 0;
        for (ll i = 0; i < n; i++) cnt[r[i + d]]++;
        for (ll i = 1; i < m; i++) cnt[i] += cnt[i - 1];
        for (ll i = n - 1; i >= 0; i--) idx[--cnt[r[i + d]]] = i;
        for (ll i = 0; i < m; i++) cnt[i] = 0;
        for (ll i = 0; i < n; i++) cnt[r[i]]++;
        for (ll i = 1; i < m; i++) cnt[i] += cnt[i - 1];
        for (ll i = n - 1; i >= 0; i--) sa[--cnt[r[idx[i]]]] = idx[i];
        nr[sa[0]] = 1;
        for (ll i = 1; i < n; ++i) nr[sa[i]] = nr[sa[i - 1]] + cmp(sa[i - 1], sa[i]);
        r = nr;
        if (r[sa[n - 1]] == n) break;
    }
    return sa;
}
vector<ll> LCP(vector<ll>& sa, string& s) {
    ll n = s.size();
    vector<ll> lcp(n,0), isa(n);
    for (ll i = 0; i < n; i++) isa[sa[i]] = i;
    for (ll k = 0, i = 0; i < n; i++) {
        if (isa[i]) {
            for (ll j = sa[isa[i] - 1]; s[i + k] == s[j + k]; k++);
            lcp[isa[i]] = (k ? k-- : 0);
        }
    }
    return lcp;
}
\end{minted}
\newpage
\section{Flow}
\subsection {dinic}
\begin{minted}{cpp}
// O(min(fE, V^2E)). But all edge's capacity are 0 or 1, then O(min(V^(2/3), E^(1/2)))
const int MAXN = 555;
struct edge {
    int to, cap, rev;
};
int level[MAXN];
int work[MAXN];
vector<edge> adj[MAXN];
void add_edge(int from, int to, int c) {
    adj[from].push_back({ to, c, (int)adj[to].size() });
    adj[to].push_back({ from, 0, (int)adj[from].size() - 1 });
}
bool bfs(int src, int sink) {
    fill(level, level + MAXN, -1);
    fill(work, work + MAXN, 0);
    level[src] = 0;
    queue<int> q;
    q.push(src);
    while (!q.empty()) {
        int now = q.front(); q.pop();
        for (auto& e : adj[now]) {
            if (e.cap > 0 && level[e.to] == -1) {
                level[e.to] = level[now] + 1;
                q.push(e.to);
            }
        }
    }
    return level[sink] != -1;
}
int dfs(int now, int sink, int amount) {
    if (now == sink) return amount;
    for (int& i = work[now]; i < adj[now].size(); i++) {
        auto e = adj[now][i];
        if (e.cap > 0 && level[e.to] == level[now] + 1) {
            int df = dfs(e.to, sink, min(amount, e.cap));
            if (df > 0) {
                adj[now][i].cap -= df;
                adj[e.to][e.rev].cap += df;
                return df;
            }
        }
    }
    return 0;
}
int dinic(int src, int sink) {
    int max_flow = 0;
    while (bfs(src, sink)) {
        while (1) {
            int df = dfs(src, sink, INF);
            if (!df) break;
            max_flow += df;
        }
    }
    return max_flow;}
\end{minted}
\newpage
\subsection {Hopcroft-Karp + Minimum Vertex Cover}
\begin{minted}{cpp}
const int MAXN = 1010, MAXM = 1010;
int dis[MAXN],l[MAXN],r[MAXM],vis[MAXN];
vector<int> adj[MAXN];
void add_edge(int l,int r) {adj[l].push_back(r);} //don't use add_edge(i, n+j), you have to add_edge(i,j)!
bool bfs(int n){
    queue<int> q;
    bool ok=0;
    memset(dis,0,sizeof(dis));
    for(int i=1;i<=n;i++) {
        if(l[i]==-1 && !dis[i]) q.push(i),dis[i]=1;
    }
    while(!q.empty()) {
        int x=q.front(); q.pop();
        for(auto &i: adj[x]) {
            if(r[i]==-1) ok=1;
            else if(!dis[r[i]]) {
                dis[r[i]]=dis[x]+1;
                q.push(r[i]);
            }
        }
    }
    return ok;
}
bool dfs(int x) {
    if(vis[x]) return 0;
    vis[x]=1;
    for(auto &i: adj[x]) {
        if(r[i]==-1 || (!vis[r[i]] && dis[r[i]] == dis[x]+1 && dfs(r[i]))) {
            l[x]=i,r[i]=x;
            return 1;
        }
    }
    return 0;
}
int match(int n){
    memset(l,-1,sizeof(l));
    memset(r,-1,sizeof(r));
    int ret=0;
    while(bfs(n)) {
        memset(vis,0,sizeof(vis));
        for(int i=1;i<=n;i++) if(l[i]==-1 && dfs(i)) ret++;
    }
    return ret;
}
//find minimum vertex cover (=bipartite matching)
//before call getcover function, you have to call match function first
bool chk[MAXN + MAXM];
void rdfs(int x, int n){
	if(chk[x]) return;
	chk[x] = 1;
	for(auto &i : gph[x]){
		chk[i + n] = 1;
		rdfs(r[i], n);
	}
}
vector<int> getcover(int n, int m){
	match(n);
	memset(chk, 0, sizeof(chk));
	for(int i=1; i<=n; i++) if(l[i] == -1) rdfs(i, n);
	vector<int> v;
	for(int i=1; i<=n; i++) if(!chk[i]) v.push_back(i);    //A
	for(int i=n+1; i<=n+m; i++) if(chk[i]) v.push_back(i); //B
	return v;
}
\end{minted}
\newpage
\subsection {Minimum Cost Maximum Flow}
\begin{minted}{cpp}
const ll N = 222, INF = 1e9;
struct edge { ll to, cap, rev, cost; };
vector<edge> adj[N];
ll dist[N], p[N], pe[N];
bool inQ[N];
void add_edge(ll u, ll v, ll c, ll cost) {
	adj[u].push_back({ v, c, (ll)adj[v].size(), cost });
	adj[v].push_back({ u, 0, (ll)adj[u].size() - 1, -cost });
}
bool spfa(ll s, ll t) {
    fill(dist, dist + N, INF);
    memset(inQ, 0, sizeof(inQ));
    queue<ll> q;
    q.emplace(s); dist[s] = 0; inQ[s] = 1;
    bool ok=0;
    while (!q.empty()) {
        ll x = q.front(); q.pop();
        if(x==t) ok=1;
        inQ[x] = 0;
        for (ll i = 0; i < adj[x].size(); i++) {
            auto e = adj[x][i];
            if (e.cap > 0 && dist[x] + e.cost < dist[e.to]) {
                dist[e.to] = dist[x] + e.cost;
                p[e.to] = x; pe[e.to] = i;
                if (!inQ[e.to]) {
                    inQ[e.to] = 1;
                    q.emplace(e.to);
                }
            }
        }

    }
    return ok;
}
pll mcmf(ll s, ll t) {
    ll min_cost = 0, max_flow=0, flow, rev;
    while (spfa(s, t)) {
        flow = INF;
        for (ll i = t; i != s; i = p[i]) flow = min(flow, adj[p[i]][pe[i]].cap);            
        min_cost += flow * dist[t];
        for (ll i = t; i != s; i = p[i]) {
            rev = adj[p[i]][pe[i]].rev;
            adj[p[i]][pe[i]].cap -= flow;
            adj[i][rev].cap += flow;
        }
        max_flow+=flow;
    }
    return { min_cost,max_flow };
}
\end{minted}
\newpage
\section{DP optimization}
\subsection {divide and conquer optimization}
\begin{minted}{cpp}
//if cost is monge C(a,c)+C(b,d)<=C(a,d)+C(b,c), a<=b<=c<=d
//or if monoticity opt(i,j)<=opt(i,j+1)
void f(int i,int s, int e, int optl, int optr) {
	//want to get dp[i][s~e]
	if(s>e) return;
	int m=s+e>>1;
	ll ret=1e18, opt=optl;
	for(ll j=optl;j<=optr;j++) {
		ll now=dp[i-1][j]+(a[m]-a[j])*(m-j);
		if(now<ret) {
			ret=now;
			opt=j;
		}
	}
	dp[i][m]=ret;
	f(i,s,m-1,optl,opt), f(i,m+1,e,opt,optr);
}
\end{minted}
\vspace{5mm}
\subsection{SOS}
\begin{minted}{cpp}
for (int i = 0; i < (1<<n); i++)
    F[i] = A[i];

for (int i = 0; i < n; i++) {  // 0...n-1 번째 축으로 훑기
    for (int x = 0; x < (1<<n); x++) {
        if (x & (1<<i))  // i번째 축 좌표가 1이므로 누적합 계산
            F[x] += F[x^(1<<i)];
    }
}
\end{minted}
\newpage
\section{ETC}
\subsection{int128}
\begin{minted}{cpp}
//-2^127~2^127-1
//use g++20(64bit) in codeforces
//use bits/stdc++.h (extc++.h cause error)
//do cin & cout with ull Or use below function
__int128 read() {
    __int128 x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
void print(__int128 x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    if (x > 9) print(x / 10);
    putchar(x % 10 + '0');
}
bool cmp(__int128 x, __int128 y) { return x > y; }
__int128 a=read();
print(a);
cout<<'\n';
\end{minted}
\newpage
\subsection{prority queue my cmp}
\begin{minted}{cpp}
//ex) min heap
struct cmp {
    bool operator()(int x, int y) {
        return a>b;
    }
};
std::priority_queue<int, vector<int>, cmp> pq;
\end{minted}
\vspace{5mm}
\subsection{distance}
\begin{minted}{cpp}
max(|x|,|y|)= |x+y|/2 + |x-y|/2
min(|x|,|y|) = |x|+|y|-max(|x|,|y|) = |x|+|y| - (|x+y|/2 + |x-y|/2)

manhatten(taxi) -> 45 rotate -> chebyshev
|x1-x2|+|y1-y2| -> max(|x1-x2|, |y1-y2|)
(x,y)->(x+y,x-y)
\end{minted}
\vspace{5mm}
\subsection{random}
\begin{minted}{cpp}
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
shuffle(all(v), rng); // shuffle randomly!
cout<<rng();     //random [0, 2^32-1]
int x=rng()%100; //[0,99]
\end{minted}
\newpage
\subsection{mo's algorithm}
\begin{minted}{cpp}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int sqrtN;
struct Query{
	int idx, s, e;
	bool operator < (Query &x){
		if(s/sqrtN != x.s/sqrtN) return s/sqrtN < x.s/sqrtN;
		return e < x.e;
	}
};
vector<Query> query;
vector<int> v;
ll res = 0;
ll ans[101010];
int main(){
	ios_base::sync_with_stdio(0); cin.tie(0);
	int n, q; cin >> n >> q; sqrtN = sqrt(n);
	v.resize(n+1);
	for(int i=1; i<=n; i++){
		cin >> v[i];
	}
	for(int i=0; i<q; i++){
		int s, e; cin >> s >> e;
		query.push_back({i, s, e});
	}
	sort(query.begin(), query.end());
	int s = query[0].s, e = query[0].e;
	for(int i=s; i<=e; i++){
		res += v[i];
	}
	ans[query[0].idx] = res;
	for(int i=1; i<q; i++){
		while(s < query[i].s) res -= v[s++];
		while(s > query[i].s) res += v[--s];
		while(e < query[i].e) res += v[++e];
		while(e > query[i].e) res -= v[e--];
		ans[query[i].idx] = res;
	}
	for(int i=0; i<q; i++) cout << ans[i] << "\n";
}
\end{minted}
\newpage
\subsection{degree sequence}
\begin{minted}{cpp}
if satisfy 1 & 2 -> can make graph
let d1>=...>=dn
1. d1+...+dn is even number
2. satisfy below inequality for all k
d1+...+dk <= k*(k-1) + min(d_k+1,k)+...+min(d_n,k)

how to construct?
1) 
ex) 6 4 4 3 3 2 2
repeat
    match largest number
    6 4 4 3 3 2 2
    0 3 3 2 2 1 1
    0 0 2 1 1 1 1
    ....
    0 0 0 0 0 0 0

2. special case: tree
if sum of di is 2n-2 : can
if sum of di isn't 2n-2 : cant
repeat
    connect leaf with nonleaf
\end{minted}
\newpage
\end{document}
